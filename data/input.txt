#include<struiuiing.h>
#include<strinjg.h>
#include<stringghj.h>
#include<strinujg.h>
#include<striuiyung.h>
ghfh

#define SIZE 20
/*
ghh*/
typedef struct Node {
	int data;
	struct Node * left;
	struct Node * right;
	int isThreaded;
}Node_t;

typedef Node_t * Node_p_t;


 typedef struct Queue {
Node_p_t array[SIZE];
        int front;
        int rear;
        int capacity;

    } Queue_t;

  typedef Queue_t * Queue_p_t;

     int isQueueFull (Queue_p_t queue) {
	if ((queue->rear + 1)%SIZE == queue->front)
		return 1;
	return 0;
    }

    int isQueueEmpty (Queue_p_t queue) {
	if (queue->front == -1 || queue->front == queue->rear)
		return 1;
	return 0;
    }


  void insert(Queue_p_t queue,Node_p_t node) {
        if(isQueueFull(queue)) {
            printf("Queue is full\n");
            exit(0);
        }

        if(isQueueEmpty(queue)) {
                    printf("Queue is empty\n");
            queue->front = queue->rear = 0;
                                   queue->array[(queue->rear)++] = node;
        }

        else if(queue->rear == SIZE-1 ) {
                                   queue->array[queue->rear] = node;
            queue->rear = 0;
        }

        else {
                                   queue->array[(queue->rear)++] = node;
         }
       printf("front = %d rear %d",queue->front,queue->rear);

   }



    Node_p_t delete(Queue_p_t queue) {
	if (isQueueEmpty(queue)) {
		//printf("\nQueue Underflow!\n\n");
		return NULL;

	}

	Node_p_t item = *(queue->array + queue->front);
	if (queue->front == queue->rear)
		queue->front = queue->rear = -1;
	else
		queue->front = (queue->front + 1)%SIZE;
	printf("Delete string %d\n",item->data);
	      printf("here front = %d rear %d",queue->front,queue->rear);
	return item;

    }

     Node_p_t pop(Queue_p_t queue) {
	if (isQueueEmpty(queue)) {
		//printf("\nQueue Underflow!\n\n");
		return NULL;

	}

		      printf("here front = %d rear %d",queue->front,queue->rear);

	return *(queue->array + queue->front);

    }

Node_p_t newNode(int item) {
	Node_p_t temp = (Node_p_t)malloc(sizeof(Node_t));
	temp->left = temp->right = NULL;
	temp->data  = item;
	return temp;
}

void inorderQueue(Node_p_t root,Queue_p_t queue) {
	if(root == NULL)
		return;
	inorderQueue(root->left,queue);
	insert(queue,root);
	inorderQueue(root->right,queue);
}


   void display (Queue_p_t queue) {
	if (isQueueEmpty(queue))
		printf("\nEmpty Queue.\n");
	else {
		printf("\nCurrent Queue : ");
		int i;
		for (i = queue->front; i < queue->rear; i = (i+1)%SIZE)
			printf("%d ", (*(queue->array + i))->data);
		//printf("\t%s\n", *(queue->array + i));
	    }
    }


   void  convertToThreaded(Node_p_t root,Queue_p_t queue) {
    	if(root == NULL)
    		return;

		convertToThreaded(root->left,queue);
		delete(queue);

		//printf("%d deleting  %d\n",root->data,temp);

    	if(root->right == NULL) {
    		root->right = pop(queue);
    		if(root->right != NULL) {
    			printf("%d linked to %d\n",root->data,root->right->data);
    			    		root->isThreaded = 1;

    		}
    	}

    	else {
		convertToThreaded(root->right,queue);
		//root->right->isThreaded = 0;

    	}

    }
Node_p_t leftMost(Node_p_t root)
{
	Node_p_t temp = root;
    while (temp != NULL && temp->left != NULL)
        temp = temp->left;
    return temp;
}

void displayThreaded(Node_p_t root) {
	Node_p_t curr = leftMost(root);
	while(curr != NULL) {
		printf("%d ",curr->data);
		if(curr->isThreaded)
			curr = curr->right;
		else
			curr = leftMost(curr->right);


	}
}

void inorder(Node_p_t root) {
	if(root != NULL) {
	inorder(root->left);
	printf("Root = %d left = %d right = %d isthreader =%d\n",root->data,root->left->data,root->right->data,root->isThreaded);
	inorder(root->right);
}
}



   int main() {
    /*       1
            / \
           2   3
          / \ / \
         4  5 6  7	 */
          Queue_t q;
    Queue_p_t queue = &q;


    queue->front = -1;
    queue->rear = -1;

    Node_p_t root = newNode(1);
    root->left = newNode(2);
    root->right = newNode(3);
    root->left->left = newNode(4);
    root->left->right = newNode(5);
    root->right->left = newNode(6);
    root->right->right = newNode(7);

    inorderQueue(root,queue);
    display(queue);
    convertToThreaded(root,queue);
    printf("root = %d",root->left->right->isThreaded);
    //inorder(root);
   displayThreaded(root);
    //createThreaded(root);

    //cout << "Inorder traversal of creeated threaded tree is\n";
    //inOrder(root);
    return 0;
}